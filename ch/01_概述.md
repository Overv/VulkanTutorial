本章将首先介绍 Vulkan 及其解决的问题。 之后，我们展示绘制一个三角形所需操作。 这个实例将为您了解后续章节提供一个宏观的介绍。我们还将总结 Vulkan API 结构及其一般的使用模式。 

## Vulkan的起源

就像之前的图形 API 一样，Vulkan 被设计为基于 [GPU] (https://en.wikipedia.org/wiki/Graphics_processing_unit) 的跨平台抽象接口。相比之下，之前的大多数图像 API 的问题在于，设计它们时所处的时代是基于图形硬件特色的，被限于可配置的固定功能。 程序员必须以标准格式提供顶点数据，并且在照明和着色选项方面受制于 GPU 制造商实际功能。

随着显卡架构的成熟，它们开始提供越来越多的可编程功能。所有这些新功能都必须以某种方式与现有 API 集成。这导致了不太理想的功能抽象和庞杂的图形驱动程序。这种情况下，程序员只能已猜测的方式将意图映射到现代图形架构上实现。这就是为什么会有如此多的驱动程序更新来提高游戏性能，有时甚至会带来明显的性能提升。然而，由于这些驱动程序的复杂性，应用程序开发人员还需要处理供应商之间的不一致问题，例如[着色器](https://en.wikipedia.org/wiki/Shader)所接受的语法。除了这些新功能外，过去十年还出现了大量具有强大图形硬件的移动设备。这些移动 GPU 根据其能量和空间要求具有不同的架构。为程序员提供更多可编程的控制能够有效改善GPU性能表现，例如[瓦片渲染](https://en.wikipedia.org/wiki/Tiled_rendering)。旧时代 API 的另一个问题是对的多线程支持程度有限，这可能导致 CPU 端出现瓶颈。

Vulkan 基于现代图形架构设计，从根本上解决了这些问题。 它通过允许程序员使用更详细的 API 清楚地指定他们的意图来减少驱动程序开销，并允许多个线程并行创建和提交命令。它通过使用单个编译器切换到标准化字节码格式来减少着色器编译造成的不一致问题。 最后，作为单一API，它整合了图形渲染与计算功能于一身，实现了现代显卡的通用处理能力。 


## 绘制三角形需要哪些操作

现在，我们将概述在 Vulkan 程序中渲染三角形所需的所有步骤。这里介绍的所有概念都将在接下来的章节中详细阐述。 这里的描述只是为给您一个展示各关联模块的宏观逻辑。 

### 步骤 1 - 实例和物理设备选择

Vulkan 应用程序首先通过 VkInstance 设置 Vulkan API。 通过描述应用程序和API 扩展来可以创建一个实例。 创建实例后，您可以查询 Vulkan 支持的硬件并选择一个或多个 VkPhysicalDevices 用于操作。 您可以查询 VRAM 大小或设备功能等属性，以选择所需的设备，例如使用专用独立显卡。

### 步骤 2 - 逻辑设备和队列族

选择要使用的正确硬件设备后，您需要创建一个 VkDevice（逻辑设备），在其中更具体地描述您将使用的 VkPhysicalDeviceFeatures，例如多视口渲染和 64 位浮点数。您还需要指定要使用的队列族。 大多数使用 Vulkan 执行的操作，例如绘制命令和内存操作，都是通过将它们提交到 VkQueue 来异步执行的。  Q队列是从队列族中分配的，其中每个队列族在其队列中支持一组特定的操作。  例如，图形、计算和内存传输操作可能有单独的队列族。队列族的可用性也可以用作物理设备选择中的一个关键因素。支持 Vulkan 的设备可能不提供任何图形功能，但是今天支持 Vulkan 的所有显卡一般都支持我们感兴趣的所有队列操作。

### 步骤 3 - 窗口表面和交换链

除非您只对离屏渲染感兴趣，否则您将需要创建一个窗口来呈现渲染图像结果。 可以使用本机窗口系统的 API 或 其他跨平台窗口库[GLFW](http://www.glfw.org/) 和 [SDL](https://www.libsdl.org/) 等库来创建窗口。我们将在本教程中使用 GLFW库，并在下一章进行详细介绍。 

我们需要另外两个组件来实际渲染到一个窗口：一个窗口表面（VkSurfaceKHR）和一个交换链（VkSwapchainKHR）。 请注意 KHR 后缀，这意味着这些对象是 Vulkan 扩展的一部分。 Vulkan API 本身完全与操作系统窗口无关，这就是为什么我们需要使用标准化的 WSI（窗口系统接口）扩展来与窗口管理器进行交互。 表面是要渲染到的窗口的跨平台抽象，通常通过提供对本机操作系统窗口句柄的引用来实例化，例如 Windows 上的 HWND。 幸运的是，GLFW 库有一个内置函数来处理平台特定的细节。 

交换链是渲染目标的集合。它的基本作用是确保我们当前渲染的图像不同于当前屏幕上的显示图像。因为这对确保屏幕只显示完整的图像很重要。每次我们想要绘制一个画面时，我们都必须要求交换链为我们提供要渲染的图像目标内容。当我们画完一帧后，图像保存在换链存储区中，以便在某个时间点切换并呈现在屏幕上。渲染目标的数量和将完成的图像呈现到屏幕上的条件取决于显示模式。常见的显示模式包括双缓冲 (vsync) 和三重缓冲。 我们将在交换链创建章节中研究这些。 

某些系统平台允许您直接渲染到显示器，不通过窗口缓冲管理器交互，无需使用 VK_KHR_display 和 VK_KHR_display_swapchain 扩展。 例如，这些系统平台允许您创建一个代表整个屏幕的表面，并可用于实现您自己的窗口管理器。 

### 步骤 4 - 图片视图与帧缓冲区

要绘制从交换链获取的图像，我们必须将其封装到 VkImageView 和 VkFramebuffer 中。 图像视图引用要使用的图像的特定关注部分，帧缓冲区则引用图像视图中关于颜色、深度和模板的部分。因为交换链中可能有多个不同的图像，我们需要预先为每个图像先创建一个图像视图和帧缓冲区，然后在绘制时选择正确的那一个。 

### 步骤 5 - 渲染通道

Vulkan 中的渲染通道描述了在渲染操作期间使用的图像类型、它们将如何使用以及应该如何处理它们的内容。 在我们最初的三角形渲染应用程序中，我们将告诉 Vulkan 我们将使用单个图像作为颜色目标，并且我们希望在绘制操作之前将其清除为纯色。渲染过程仅描述图像的类型，通过对 VkFramebuffer 槽参数设置，从而间接关联到其绑定的对应图像。


### 步骤 6 - 图形管线（graphics pipeline）

Vulkan 中的图形管道是通过创建 VkPipeline 对象来设置的。 它描述了显卡的可配置状态，例如视口大小、深度缓冲区操作以及使用 VkShaderModule 对象的可编程状态。 VkShaderModule 对象是从着色器字节码创建的。 驱动程序还需要知道管道中将使用哪些渲染目标，我们通过引用渲染通道（render pass）来指定。

与现有的其他图形 API 相比，Vulkan 最显着的特点之一是图形管线的几乎所有配置都需要提前设置。这意味着如果你想切换到不同的着色器或稍微改变你的顶点布局，那么你需要重新创建图形管线。这意味着您必须提前为渲染操作所需的所有不同组合创建许多 VkPipeline 对象。 只有一些基本配置，如视口大小和清晰颜色，可以动态更改。所有的状态也需要明确描述，例如没有默认的颜色混合状态。

好消息是，对于等效操作，由于您执行的是提前编译而非即时编译，因此驱动程序有更多优化机会，并且运行时性能可预测更好，因为大的状态变化，例如切换到不同的图形管线将变得非常明确。

### 步骤 7 - 命令池和命令缓冲区

如前所述，Vulkan 中很多我们想要执行的操作，比如绘图操作，都需要提交到队列中。这些操作首先需要记录到 VkCommandBuffer 中才能提交。这些命令缓冲区是从与特定队列族(queue family)关联的 VkCommandPool 分配的。要绘制一个简单的三角形，我们需要记录一个命令缓冲区，其操作如下：

* 开始一个渲染通道（render pass）
* 将渲染通道绑定到图形管线（graphics pipeline）
* 绘制三顶点
* 结束渲染通道（render pass）

因为帧缓冲区中的图像来自交换链将给我们的具体图像，所以我们需要为每个可能的图像记录一个命令缓冲区，并在绘制时选择正确的一个。 另一种方法是每帧单独记录命令缓冲区，但这种方式效率不高。

### 步骤 8 - 主循环

现在绘图命令已被封装到命令缓冲区中，主循环就非常简单了。 我们首先使用 vkAcquireNextImageKHR 从交换链中获取图像。 然后我们可以为该图像选择适当的命令缓冲区并使用 vkQueueSubmit 执行它。 最后，我们将图像返回到交换链，以便使用 vkQueuePresentKHR 呈现到屏幕上。

提交到队列的操作是异步执行的，提交操作会立即返回。因此，我们必须使用信号量等同步对象来确保程序的正确执行顺序。命令缓冲区需要设置等待条件，必须等到图像内容采集读取完成，而后才能开始对图像进行绘制操作，否则读取与渲染操作同时进行，前时刻渲染结果与当前渲染结果可能会同时显示在屏幕上。同样的，vkQueuePresentKHR 画面显示也需要等待渲染完成，为此我们将使用第二个信号量待渲染完成后发出。

### 总结

这纠缠的逻辑应该让您对绘制第一个三角形的工作有一个基本的了解。完整的真实程序包含更多步骤，例如分配顶点缓冲区、创建统一缓冲区和上传纹理图像，这些步骤将在后续章节中介绍，但我们将从简单开始，因为 Vulkan 有陡峭的学习曲线。 请注意，最初的例子我们会将顶点坐标直接嵌入写到顶点着色器中，而不是使用顶点缓冲区。 这是因为管理顶点缓冲区需要先熟悉命令缓冲区。 

简而言之，绘制第一个三角形我们需要如下步骤：

* 创建一个VkInstance对象
* 选择合适的显卡设备(VkPhysicalDevice)
* 创建逻辑设备VkDevice和命令队列VkQueue来绘制和显示
* 创建一个窗体对象、窗体绘制面和交换链
* 将交换链种的图像对象封装到图像视图中VkImageView
* 创建一个渲染通道render pass用以指明渲染目标和用途
* 为渲染通道创建帧缓冲区
* 设置图像管线
* 为每一个绘制图像分配命令缓冲区并指明绘制操作
* 获取图像并绘制，提交正确的绘制命令并将绘制结果换回给交换链并用于显示

这包括了很多步骤，但每个单独步骤的目的将在接下来的章节中变得非常简单明了。如果你对单个步骤与整个程序的关系感到困惑，你应该回到本章了解步骤说明。

## API 概念

下面将简要概述如何在底层使用 Vulkan API 构建应用。

### 编码规范

所有 Vulkan 函数、枚举和结构都定义在 vulkan.h 头文件中，该头文件包含在 LunarG 开发的 [Vulkan SDK](https://lunarg.com/vulkan-sdk/) 中。 我们将在下一章中研究如何安装这个 SDK。 

函数有一个小写的`vk`前缀，像枚举和结构这样的类型有一个`Vk`前缀，枚举值有一个`VK_`前缀。 API 大量使用结构来为函数提供参数。 例如，创建对象通常遵循以下模式： 

```c++
VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "failed to create object" << std::endl;
    return false;
}
```

Vulkan 中的许多结构都要求您明确指定`sType` 成员中的结构。 `pNext` 成员可以指向扩展结构，并且在本教程中始终为 `nullptr`。 创建或销毁对象的函数将具有 VkAllocationCallbacks 参数，该参数允许您使用自定义分配器来分配驱动程序内存，在本教程中也将保留为 `nullptr`。 

几乎所有函数都返回一个 VkResult，它要么是“VK_SUCCESS”，要么是错误代码。该规范描述了每个函数可以返回哪些错误代码以及它们的含义。 

### 验证层

如前所述，Vulkan 专为高性能和减少驱动程序开销而设计。 因此，默认情况下它将包括非常有限的错误检查和调试功能。 如果您做错了什么，驱动程序通常会崩溃而不是返回错误代码，或者更糟，它可能在您的显卡上能够正常运行而在其他显卡上则会失败。 

Vulkan 允许您通过称为*验证层*的功能启用广泛的检查。 验证层是可以插入 API 和图形驱动程序之间的代码片段，用于对函数参数运行额外检查和跟踪内存管理问题。 好处是您可以在开发过程中启用它们，然后在发布应用程序时完全禁用它们以实现零开销。 任何人都可以编写自己的验证层，而 LunarG 的 Vulkan SDK 提供了一组标准的验证层，我们将在本教程中使用它们。 您还需要注册一个回调函数来接收来自层的调试消息。 

因为 Vulkan 对每个操作都非常明确，验证层的可扩展性很强，所以与 OpenGL 和 Direct3D 相比，Vulkan更容易排查错误，比如有些时候为什么你的屏幕显示会是黑色的！ 

在我们开始编写代码实践之前只有一步，那就是[设置开发环境](!ch/设置开发环境)。 
