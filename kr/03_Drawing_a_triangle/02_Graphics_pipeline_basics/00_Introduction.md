다음 몇 챕터에서 우리는 첫 번째 삼각형을 그리기 위한 그래픽스 파이프라인을 설정할 것입니다. 그래픽스 파이프라인이란 메쉬(mesh)의 정점(vertex)들과 텍스처들을 받아서 렌더 타겟의 픽셀로 출력하기 위한 일련의 연산들을 말합니다. 간단한 개요가 아래 그림에 표현되어 있습니다:

![](/images/vulkan_simplified_pipeline.svg)

*입력 조립(input assembler)*은 명시한 버퍼로부터 정점 데이터를 수집합니다. 또한 인덱스 버퍼를 사용하여 특정 요소들을 정점 데이터의 중복 없이 반복 사용할 수 있도록 할 수도 있습니다.

*정점 셰이더(vertex shader)*는 각 정점에 대해 실행되며, 일반적으로 정점의 위치를 모델 공간으로부터 스크린 공간으로 변환하는 작업을 합니다. 또한 정점별(per-vertex) 데이터를 파이프라인의 다음 단계로 전달합니다.

*테셀레이션 셰이더(tessellation shaders)*는 특정한 규칙에 따라 기하(geometry)를 분할하여 메쉬의 품질을 향상시킬 수 있는 과정입니다. 이는 벽돌로 된 벽이라던가, 계단과 같은 표면에 적용되어 가까이서 봤을 때 덜 평평하게(flat) 보이도록 하는 데 자주 사용됩니다.

*기하 셰이더(geometry shader)*는 모든 프리미티브(삼각형, 선, 점)에 대해 실행되며 그 정보를 탈락(discard)시키거나 입력된 것보다 더 많은 프리미티브를 생성할 수 있습니다. 테셀레이션 셰이더와 비슷하지만 훨씬 유연합니다. 하지만 요즘 응용 프로그램에서는 자주 사용되지 않는데 인텔의 내장 그래픽 카드를 제외하고 대부분 그래픽 카드에서는 성능이 그리 좋지 않기 때문입니다.

_래스터화(rasterization)_ 단계는 프리미티브를 *프래그먼트*로 이산화하는 단계입니다. 프래그먼트는 픽셀 요로소 프레임버퍼에 채워집니다. 화면 밖에 놓여 있는 프래그먼트는 버려지고 정점 셰이더의 출력 어트리뷰트(attribute)는 프래그먼트들에 걸쳐 그림에 보이는 것과 같이 보간됩니다. 다른 프리미티브 프래그먼트 뒤에 놓여있는 프래그먼트도 깊이 테스트(depth test)에 의해 버려집니다.

*프래그먼트 셰이더(fragment shader)*는 모든 살아남은 프래그먼트에 대해 실행되며 어떤 프레임버퍼에 프래그먼트가 쓰여질지, 어떤 색상과 깊이값이 쓰여질지를 결정합니다. 이는 정점 셰이더에서 보간된 데이터를 바탕으로 이루어지며 데이터는 텍스처 좌표계와 라이팅(lighting)을 위한 법선(normal) 정보 같은 것들이 포함됩니다.

_컬러 블렌딩(color blending)_ 단계는 프레임버퍼의 같은 픽셀에 맵핑되는 다른 프래드먼트들을 섞는 연산을 적용합니다. 프래그먼트 값들이 다른 값들을 대체할 수도 있고, 투명도에 따라 더해지거나 섞일 수 있습니다.

녹색으로 표현된 단계는 _고정 함수(fixed-function)_ 단계로 알려져 있습니다. 이 단계들은 매개변수를 사용해 연산을 약간 변경할 수 있지만, 동작 방식 자체는 미리 정의되어 있습니다.

주황색으로 표시된 단계는 `programmable`한 단계인데, 여러분이 작성한 코드를 그래픽 카드에 업로드할 수 있어서 원하는 대로 연산을 할 수 있다는 뜻입니다. 이렇게 되면 예를 들어 프래그먼트 셰이더에서 텍스처링이라던지 레이 트레이싱(ray tracing)을 위한 라이팅 등을 구현할 수 있게 됩니다. 이러한 프로그램은 여러 객체(예를들어 정점 또는 프래그먼트)들을 처리하기 위해 여러 GPU 코어에서 동시에 병렬적으로 실행됩니다.

OpenGL이나 Direct3D같은 예전 API를 사용해 봤다면, 파이프라인의 설정을 바꾸는 `glBlendFunc`와 `OMSetBlendState` 같은 함수의 사용에 익숙할 것입니다. Vulkan의 그래픽스 파이프라인은 거의 완전히 불변적(immutable)이라서, 셰이더를 바꾸거나 다른 프레임버퍼를 바인딩(bind)한다거나 블렌딩 함수를 바꾸거나 할 떄에는 파이프라인을 처음부터 다시 만들어야 합니다. 이에 대한 단점으로는 우리가 사용하고자 하는 렌더링 연산을 위한 다양한 상태를 표현하는 모든 조합에 대해 파이프라인들을 만들어야 한다는 것입니다. 하지만, 파이프라인에서 수행하는 모든 연산에 대해 미리 말게되기 때문에, 드라이브가 훨씬 최적화를 잘 할 수 있는 장점도 있습니다.

여러분이 하려는 작업에 따라서 몇 개의 프로그램가능한(programmable) 단계는 선택적으로 사용해도 됩니다. 예를 들어 테셀레이션과 기하 단계는 간단한 형상을 그릴 떄에는 활성화하지 않아도 됩니다. 깊이 값에만 관심이 있다면 프래그먼트 셰이더 단계를 비활성화 할수도 있는데 [그림자 맵](https://en.wikipedia.org/wiki/Shadow_mapping) 생성을 할 때에는 유용할 것입니다.

다음 장에서는 삼각형을 화면에 표시하기 위한 두 개의 프로그램 가능한 단계(정점 셰이더와 프래그먼트 셰이더)를 만들어 볼 것입니다. 고정된 함수 구성인 블렌딩 모드, 뷰포트(viewport), 래스터화 같은 단계는 그 다음 챕터에서 설정할 것입니다. Vulkan에서의 그래픽스 파이프라인을 위한 마지막 설정 단계는 입력과 출력 프레임버퍼와 관련되어 있습니다.

`initVulkan`의 `createImageViews` 바로 뒤에 호출할 `createGraphicsPipeline` 함수를 만들겠습니다. 이후 챕터에서 이 함수를 만들어 나갈 것입니다.

```c++
void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
    createSwapChain();
    createImageViews();
    createGraphicsPipeline();
}

...

void createGraphicsPipeline() {

}
```

[C++ code](/code/08_graphics_pipeline.cpp)
