이 챕터에서는 Vulkan에 대한 개요와 Vulkan이 해결하고자 하는 문제에 대한 설명부터 시작해 보겠습니다. 그 이후엔 첫 삼각형을 그리기 위해 필요한 재료들을 살펴볼 것입니다. 이를 통해 이후 챕터에서 다루는 내용들에 대한 큰 그림을 이해할 수 있을 것입니다. 마지막에는 Vulkan API의 구조와 일반적인 사용 패턴을 다루는 것으로 마무리 할 것입니다.

## Vulkan의 탄생

기존의 그래픽스 API와 마찬가지로, Vulkan은 [GPUs](https://en.wikipedia.org/wiki/Graphics_processing_unit)에 대한 크로스 플랫폼 추상화를 위해 설계되었습니다. 이러한 API들의 문제점은 그들이 설계된 시기에는 그래픽 하드웨어들이 대부분 고정된 기능 구성으로 제한되어 있었다는 것입니다. 프로그래머는 표준 포맷으로 정점(Vertex) 데이터를 넘겨주어야 했고 조명과 셰이딩 옵션은 API 제조사에서 제공하는 기능을 사용해야 했습니다.

그래픽 카드의 아키텍처가 발전하면서 점점 더 많은 프로그램가능한(programmable) 기능을 제공하기 시작했습니다. 이러한 새로운 기능은 어떻게든 기존 API와 통합되어야 했습니다. 이에 따라 이상적인 추상화와는 멀어지기 시작했고, 프로그래머의 의도와 현대적인 그래픽스 아키텍처간의 맵핑을 위해 그래픽 드라이버 내부에 대한 어림짐작들이 포함되기 시작했습니다. 이것이 게임의 성능 향상을 위해 많은 드라이버 업데이트가 필요한 이유고, 때때로 인로 인해 많은 성능 향상이 일어나기도 합니다. 드라이버의 복잡성 때문에 응용 프로그램 개발자들은 벤더(vendor) 사이의 불일치를 다루어야 하기도 하는데, 예를 들어 어떤 [셰이더](https://en.wikipedia.org/wiki/Shader) 문법이 받아들여지는지 아닌지와 같은 것입니다. 이러한 새로운 기능 이외에도, 지난 십 년 동안 새로 시작에 편입된 강력한 그래픽 하드웨어를 가진 모바일 기기가 있습니다. 이 모바일 GPU는 전력과 공간 요구사항으로 인해 또다른 아키텍처를 가지게 되었습니다. 한 예로 [tiled rendering](https://en.wikipedia.org/wiki/Tiled_rendering)이 있는데, 이 기능에 대해 프로그래머에게 보다 많은 제어 권한을 부여함으로써 성능이 향상될 수 있었습니다. 이러한 API의 설계 시기에 기인한 또 다른 문제로 멀티쓰레딩의 제약이 있습니다. 이로 인해 CPU 단에서의 병목이 발생하기도 합니다.

Vulkan은 처음부터 현대적인 그래픽스 아키텍처에 기반한 설계를 통해 이러한 문제를 해결합니다. 보다 장황한 API를 통해 프로그래머가 의도를 명확하게 기술할 수 있게 함으로써 드라이버의 오버헤드(overhead)를 줄이고, 멀티쓰레드로 커맨드(command)을 병렬적으로 생성 및 제출(submit)할 수 있습니다. 단일 컴파일러, 표준화된 바이트 코드로 변경함으로써 셰이더 컴파일의 불일치 문제도 해결합니다. 마지막으로 그래픽스와 계산 기능을 단일 API로 병합하여 현대 그래픽 카드의 범용 계산(general purpose) 기능을 공식적으로 지원합니다.

## 삼각형을 그리기 위해 필요한 것들

이제 잘 만들어진 Vulkan 프로그램이 삼각형 하나를 그리기 위해 어떤 단계들을 거치는지 알아볼 것입니다. 여기 소개하는 모든 개념들은 다음 챕터들에서 보다 상세히 다룰 것입니다. 지금은 모든 각각의 컴포넌트들의 관계에 대한 큰 그림을 이해하면 됩니다.

### 1단계 - 인스턴스와 물리 장치(physical device) 선택

Vulkan 응용 프로그램은 `VkInstance`를 통해 Vulkan API를 설정함으로써 시작합니다. 인스턴스는 여러분의 응용 프로그램과 사용할 API 확장(extension)을 기술(describe)함으로써 생성됩니다. 인스턴스 생성 이후에는, Vulkan을 지원하는 하드웨어들을 쿼리하고 사용할 하나 이상의 `VkPhysicalDevice`를 선택합니다. 적절한 장치(예를 들어 특정 그래픽 카드)를 선택하기 위해 VRAM 크기라던데 장치의 기능들도 쿼리할 수 있습니다.

### 2단계 - 논리적 장치(logical device)와 큐 패밀리(queue family)

사용할 적절한 하드웨어를 선택한 뒤에는, 논리적 장치인 VkDevice를 만들어야 합니다. 이를 통해 좀 더 상세하게 다중 뷰포트 렌더링을 할 것인지, 64 bit float을 사용할지와 같은 상세 VkPhysicalDeviceFeatures를 기술합니다. 또한 어떤 큐 패밀리를 사용할지 명시해야 합니다. 그리기 커맨드나 메모리 연산과 같은 대부분의 연산들은 Vulkan을 통해 수행되는데 이는 이러한 작업들을 VkQueue에 제출한 후 비동기적으로 실행됩니다. 큐는 큐 패밀리에 할당되는데, 각 큐 패밀리는 큐에 있는 특정 연산의 집합을 지원합니다. 예를 들어, 그래픽스를 위한 큐 패밀리, 계산을 위한 큐 패밀리, 메모리 전송을 위한 큐 패밀리가 있을 수 있습니다. 큐 패밀리의 가용 여부는 물리적 장치 선택의 구분 기준으로도 활용될 수 있습니다. Vulkan을 지원하지만 그래픽스 연산 기능을 전혀 지원하지 않는 장치가 있을 수도 있습니다. 하지만 오늘날 Vulkan을 지원하는 모든 그래픽 카드들은 일반적으로 우리가 필요로 하는 모든 큐 연산을 지원하고 있습니다.

### 3단계 - 윈도우 표면(window surface)과 스왑 체인(swap chain)

오프스크린 렌더링만을 하지 않는 한, 렌더링된 이미지를 표시할 윈도우가 필요합니다. 윈도우는 [GLFW](http://www.glfw.org/)와 [SDL](https://www.libsdl.org/) 같은 네이티브 플랫폼 API나 라이브러리를 사용해 만들 수 있습니다. 이 튜토리얼에서는 GLFW를 사용할 것이고, 자세한 내용은 다음 챕터에서 다루겠습니다.

실제 윈도우에 렌더링을 하기 위해서는 두 가지 컴포넌트가 더 필요합니다. 윈도우 표면(VkSurfaceKHR)과 스왑 체인(VkSwapchainKHR)입니다. `KHR` 접미어는 이것들이 Vulkan 확장의 일부임을 의미합니다. Vulkan API는 완벽히 플랫폼 독립적이며, 이로 인해 우리는 윈도우 매니저와 상호작용하기 위해서 표준화된 WSI (Window System Interface)를 사용해야만 합니다. 표면(surface)은 렌더링을 수행할 윈도우에 대한 크로스 플랫폼적 추상화를 의미하고 일반적으로 네이티브 윈도우 핸들(예를 들어 윈도우의 경우에는 `HWND`)에 대한 참조를 제공하여 인스턴스화됩니다. 다행히 GLFW 라이브러리는 여러 플랫폼들에 대한 이러한 상세 사항을 처리해 주는 내장 함수를 제공하고 있습니다.

스왑 체인은 렌더 타겟(render target)의 집합입니다. 스왑 체인의 기본 목적은 우리가 현재 렌더링을 수행하고 있는 이미지와 화면에 그려진 이미지를 달리하는 데 있습니다. 완전히 다 그려진 이미지만을 화면에 표시하기 위한 중요한 기능입니다. 프레임(frame)을 그리기 위해서는 먼저 스왑 체인에 렌더링을 수행할 대상 이미지를 요청해야 합니다. 프레임 그리기가 끝나면, 이미지는 스왑 체인에 반환되어 어느 시점에 화면에 그려지게 됩니다. 렌더 타겟의 개수와 화면에 표시되는 상태는 표시 모드(present mode)를 통해 기술됩니다. 일반적인 표시 모드로는 이중 버퍼링(vsync)과 삼중 버퍼링입니다. 스왑 체인 생성 챕터에서 자세히 살펴볼 것입니다.

어떤 플랫폼들은 `VK_KHR_display`와 `VK_KHR_display_swapchain` 확장을 통해 윈도우 관리자(manager)와 상호작용하지 않고 곧바로 화면에 그릴 수 있도록 허용하기도 합니다. 이 확장들은 전체 스크린을 표시하는 표면을 만들 수 있고, 이를 이용하여 예를 들자면 여러분 스스로 윈도우 관리자를 구현하는 데 사용될 수 있습니다.

### 4단계 - 이미지 뷰와 프레임버퍼(framebuffer)

스왑 체인으로부터 얻은 이미지에 그리기(draw)를 하기 위해서는 이미지를 VkImageView와 VkFramebuffer로 래핑(wrap)해야 합니다. 이미지 뷰는 사용될 이미지의 특정 부분을 참조하고, 프레임버퍼는 색상, 깊이, 스텐실(stensil) 그리기의 대상이 되는 이미지 뷰를 참조합니다. 스왑 체인에 여러 이미지들이 있을 수 있기 떄문에, 그 각각의 이미지에 대해 미리 이미지 뷰와 프레임버퍼를 생성해 두고 그리기 시점에 적절한 것들을 선택해야 합니다.

### 5단계 - 렌더 패스(pass)

Vulkan에서의 렌더 패스는 렌더링 연상 과정에 사용될 이미지의 타입을 기술합니다. 그것이 어떻게 사용될지, 그 내용이 어떻게 취급될지와 같은 것들 말입니다. 삼각형 그리기 응용 프로그램에서는 우리는 Vulkan에게 단일 이미지를 색상 타겟으로 사용할 것이고, 그리기 연산이 수행되기 직전에 단일 색상으로 지울(clear)것을 명시할 것입니다. 렌더 패스는 이미지의 타입만 지정하고, VkFramebuffer가 실제로 특정 이미지를 그 슬롯(slot)에 바인딩(bind)합니다.

### 6단계 - 그래픽스 파이프라인

Vulkan에서의 그래픽스 파이프라인은 VkPipeline 객체를 만들어서 설정됩니다. 뷰포트 크기와 깊이 버퍼 연산과 같은 그래픽 카드의 상태 구성 방법과 VkShaderModule 객체를 통한 프로그램 가능한 상태와 같은 것들을 기술합니다. VkShaderModule은 셰이더의 바이트 코드로부터 생성됩니다. 드라이버는 파이프라인에서 어떤 렌더 타겟이 사용될지 알아야 하는데 이는 렌더 패스 참조를 통해 명시할 수 있습니다.

Vulkan과 기존 API간의 가장 큰 차이점은 거의 모든 그래픽스 파이프라인의 구성이 미리 설정되어야 한다는 것입니다. 즉, 여러분이 사른 셰이더를 사용하거나 정점의 레이아웃(layout)을 살짝 바꾸려고 할 때에도 그래픽스 파이프라인 전체를 다시 생성해야 한다는 것입니다. 그 말은 렌더링 연산을 위한 여러 조합들에 대해 VkPipeline들을 미리 만들어놔야 한다는 뜻입니다. 몇 가지 기본적인 구성, 예를 들어 뷰포트 크기나 지움(clear) 색상과 같은 것들만 동적으로 바꿀 수 있습니다. 또한 모든 상태는 명시적으로 기술되어야 합니다. 예를 들어 색상 혼합(blend) 상태의 기본값(default) 같은 것은 제공되지 않습니다.

좋은 소식은 이러한 작업들이 ahead-of-time 컴파일과 just-in-time 컴파일의 차이 같은 것이라, 드라이버가 미리 최적화 할 수 있는 여지가 많고, 런타임 성능이 보다 예측하기 쉽다는 것입니다. 왜냐하면 다른 그래픽스 파이프라인으로의 변경과 같은 큰 상태 변화가 매우 명시적으로 표현되기 때문이지요.

### 7단계 - 커맨드 풀(pool)과 커맨드 버퍼

앞서 이야기한 것처럼, 우리가 실행하고자 하는, 예를 들자면 그리기와 같은 Vulkan의 많은 연산들은 큐에 제출되어야 합니다. 이러한 연산들은 제출되기 전에 VkCommandBuffer에 먼저 기록되어야 합니다. 이러한 커맨드 버퍼는 `VkCommandPool`로부터 할당되고 이는 특정한 큐 패밀리와 연관(associate)되어 있습니다. 간단한 삼각형을 그리기 위해서는 아래와 같은 연산들을 커맨드 버퍼에 기록해야 합니다.

- 렌더 패스 시작
- 그래픽스 파이프라인 바인딩
- 3개 정점 그리기
- 렌더 패스 종료

프레임버퍼의 이미지는 스왑 체인이 우리에게 전달해준 이미지에 의존하기 때문에, 커맨드 버퍼에 기록할 명령어는 모든 가능한 이미지에 대해 기록되어야 하고, 그리기 시점에 올바른 것이 선택되어야 합니다. 다른 방법으로는 매 프레임마다 커맨드 버퍼를 기록하는 것인데, 그리 효율적이지 않습니다.

### 8단계 - 메인 루프(main loop)

그리기 커맨드가 커맨드 버퍼에 기록되었으므로 메인 루프는 직관적입니다. 먼저 스왑 체인으로부터 vkAcquireNextImageKHR를 통해 이미지를 얻습니다. 그리고 해당 이미지에 적합한 커맨드 버퍼를 선택하고 vkQueueSubmit를 통해 실행합니다. 마지막으로 vkQueuePresentKHR를 통해 이미지를 스왑 체인에 반환하여 화면에 표시되게 합니다.

큐에 제출된 연산들은 비동기적으로 실행됩니다. 따라서 세마포어와 같은 동기 객체를 사용하여 실행이 올바른 순서로 이루어지도록 해야 합니다. 그리기 커맨드 버퍼의 실행은 이미지 획득 이후에 되도록 해야 합니다. 그렇지 않으면 화면에 표시하기 위해 읽고 있는 이미지에 렌더링이 수행될 수도 있습니다. vkQueuePresentKHR의 호출은 렌더링이 끝날 때까지 기다려야 하는데 이를 위해서는 렌더링이 끝나면 신호를 보내는 두 번째 세마포어를 사용해야 할 것입니다.

### 요약

이 정신없는 소개를 통해 삼각형을 그리기 앞서 알아야 할 것들에 대한 기본적인 이해가 되었길 바랍니다. 실제 프로그램은 몇 가지 단계가 더 필요한데, 정점 버퍼를 할당한다던지, 유니폼(uniform) 버퍼를 만들고 텍스처 이미지를 업로드한다던다 하는 것이고, 이어지는 챕터에서 소개할 것입니다. 우선은 간단히 시작할 것인데 Vulkan의 학습 곡선이 이미 충분히 가파르기 때문입니다. 주의하실 것은 초기에 우리는 정점의 좌표를 정점 버퍼를 사용하는 대신 정점 셰이더에 직접 하드코딩 하는 편법을 쓸 것입니다. 이는 정점 버퍼를 사용하기 위해서는 우선 커맨드 버퍼에 익숙해져야 하기 때문입니다.

요약하자면, 삼각형을 그리기 위해서 우리는:

- VkInstance 생성
- 지원하는 그래픽 카드 선택 (VkPhysicalDevice)
- 그리기와 표시를 위해 VkDevice와 VkQueue 생성
- 윈도우, 윈도우 표면 및 스왑 체인 생성
- VkImageView로 스왑 체인 이미지 래핑
- 렌더 타겟과 사용법을 명시하는 렌더 패스 생성
- 렌더 패스를 위한 프레임버퍼 생성
- 그래픽스 파이프라인 설정
- 모든 후보 스왑 체인 이미지에 대해 커맨드 버퍼를 할당하고 그리기 커맨드를 기록
- 이미지를 획득하고, 올바른 그리기 커맨드를 제출하고, 이미지를 스왑 체인에 반환하여 프레임 그리기

단계가 많지만 개별 단계의 목적에 대해서는 이후 챕터에서 명확하고 단순하게 설명할 것입니다. 개별 단계와 전체 프로그램의 관계에 대해 헷갈리시면 이 챕터로 다시 돌아 오십시오.

## API 컨셉

이 챕터는 Vulkan API가 저수준에서 어떻게 구조화 되어있는지를 간략히 살펴보는 것으로 마치겠습니다.

### 코드 작성 규칙(convention)

모든 Vulkan 함수, 열거형과 구조체들은 `vulkan.h` 헤더에 정의되어 있고, 이는 LunarG가 개발한 [Vulkan SDK](https://lunarg.com/vulkan-sdk/)에 포함되어 있습니다. 다음 챕터에서 이 SDK를 설치할 것입니다.

함수는 소문자 `vk` 접두어를 갖고, 열거형 및 구조체와 같은 타입은 `Vk` 접두어, 열거자 값은 `VK_` 접두어를 갖습니다. API는 함수에 매개변수 전달을 위해 구조체를 아주 많이 사용합니다. 예를 들어, 객체의 생성은 대개 아래와 같은 패턴을 따릅니다:

```c++
VkXXXCreateInfo createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "failed to create object" << std::endl;
    return false;
}
```

Vulkan의 많은 구조체들은 해당 구조체의 타입을 `sType` 멤버를 통해 명시적으로 명시하도록 되어 있습니다. `pNext` 멤버는 확장 구조를 가리킬 수 있도록 되어 있는데 이 튜토리얼에서는 항상 `nullptr`입니다. 객체를 생성하서나 소멸(destroy)하는 함수는 VkAllocationCallbacks 매개변수를 가지고 있어서 드라이버 메모리에 대한 커스텀 할당자(allocator)를 사용할 수 있도록 하는데 이 역시 이 튜토리얼에서는 항상 `nullptr`로 둘 것입니다.

대부분의 함수는 VkResult를 반환하고 이는 `VK_SUCCESS`이거나 오류 코드입니다. 명세를 보면 각 함수가 반환할 수 있는 오류 코드와 그 의미가 적혀 있습니다.

### 검증 레이어(validation layer)

앞서 이야기한 것처럼, Vulkan은 고성능과 적은 드라이버 오버헤드를 위해 설계되었습니다. 따라서 기본적으로는 아주 제한적인 오류 체킹과 디버깅 기능만을 포함하고 있습니다. 코드를 잘못 작성하는 드라이버는 오류 코드를 반환하는 대신 그냥 크래쉬(crash)가 발생하거나, 더 나쁜 경우에는 여러분의 그래픽 카드에서는 제대로 동작하는 것처럼 보이지만 다른 그래픽 카드에서는 전혀 동작하지 않을겁니다.

Vulkan은 꼼꼼한 오류 체크를 *검증 레이어(validation layer)* 기능을 통해 제공합니다. 검증 레이어는 API와 그래픽 드라이버 사이에 삽입되는 코드로 함수 매개변수에 대한 추가적인 검증이나 메모리 관리 문제를 추적하는 데 사용됩니다. 좋은 점은 이러한 기능을 개발 과정에서 사용하고 릴리즈 할 때에는 완전히 사용하지 않도록 하여 오버헤드를 없앨 수 있다는 것입니다. 스스로 검증 레이어를 작성할 수도 있지만, LunarG가 만든 Vulkan SDK는 표준적인 검증 레이어를 제공하고, 이 튜토리얼에서는 그것을 사용할 것입니다. 여러분은 레이어에서 날아온 디버깅 메시지를 처기하기 위한 콜백 함수를 등록해야 합니다.

Vulkan의 각 연산은 아주 명시적이고 검증 레이어는 꼼꼼하기 떄문에 화면이 검은 색 밖에 안나오는 경우에 OpenGL이나 Direct3D보다 그 원인을 찾기가 훨씬 쉽습니다!

코드를 작성하기 전에 시작해야 할 남은 한 단계는 [개발 환경을 설정](!kr/Development_environment)하는 것입니다.
